/// The module consists of methods and structures for C++
/// and SWIG code generation. The generated code depends
/// on header files generated by `swift-bridge` crate.
///
use crate::{
    binding_types::{Function, RustWrapperType, WrapperType},
    extern_module_translator::ExternModuleTranslator,
};
use std::collections::HashSet;

/// Helper structure that consists of a generated C++ glue code
/// and SWIG interface file with templates.
///
pub struct GeneratedFilesContent {
    pub cpp_header: String,
    pub swig_interface: String,
}

/// Predefined C++ classes and primitive types typedefs useful
/// during the standard work on FFI basic structures. It
/// consists of a custom RustVector and String implementations
/// that keep track of some object ownership aspects. Items
/// returned by `RustVec::at(x)` method should be treated as
/// references, since the underlying objects are owned by
/// the vector.
///
///
const PREDEFINED: &str = "
#include <string>
#include <cstring>

typedef unsigned long u64;
typedef unsigned int u32;
typedef unsigned short u16;
typedef unsigned char u8;
typedef long i64;
typedef int i32;
typedef short i16;
typedef char i8;
typedef long unsigned int uintptr_t;

template <typename T>
class RustVec {
    void* self = nullptr;
public:
    RustVec() = delete;
    RustVec(RustVec&& a) : self(a.self) {
        a.self = nullptr;
    };
    RustVec(void* self) : self(self) {{}}
    virtual ~RustVec();
    operator void*() const { return this->self; }

    // TODO: Add a method that copies the given item.
    // TODO: implement iterator for RustVec.
    void push(T& item);
    T at(uintptr_t index);
    size_t size();
};

class String {
    void* self = nullptr;
    std::string str;
public:
    String() = delete;
    String(void* self, bool is_owned = true) : self(self) {{ }}
    String(const char* str) {
        this->str = std::string(str);
        RustStr s = RustStr {
            this->str.c_str(),
            this->str.size()
        };
        this->self = __swift_bridge__$RustString$new_with_str(s);
    }
    String(String&& a)
        : self(a.self) { 
              a.self = nullptr; 
    }
    std::string to_string() {
        RustStr s = __swift_bridge__$RustString$as_str(this->self);
        return std::string((const char*)s.start);
    }
    operator void*() const { return this->self; }
};
";

/// Creates an implementation of RustVec<T> for a given T that maps to the Rust Vec<T> object.
///
macro_rules! vector_impl {
    ($inner_type:expr, $inner_function_name:expr) => {
        format!(
            "
template<>
RustVec<{0}>::~RustVec() 
{{
    if(this->self) {{
        __swift_bridge__$Vec_{1}$drop(this->self);
    }}
}}
template<>
void RustVec<{0}>::push({0}& item) {{ __swift_bridge__$Vec_{1}$push(this->self, item); }}
template<>
{0} RustVec<{0}>::at(uintptr_t index) {{ return {0}(__swift_bridge__$Vec_{1}$get(this->self, index)); }}
template<>
size_t RustVec<{0}>::size() {{ return (size_t)  __swift_bridge__$Vec_{1}$len(this->self); }}",
        $inner_type, $inner_function_name
        )
    };
}

/// Creates an implementation of RustVec<T> for a given primitive type T that maps
/// to the Rust Vec<T> object.
///
macro_rules! vector_primitive_impl {
    ($inner_type:expr, $inner_function_name:expr) => {
        format!(
            "
template<>
RustVec<{0}>::~RustVec() 
{{
    if(this->self) {{
        __swift_bridge__$Vec_{1}$_free(this->self);
    }}
}}
template<>
void RustVec<{0}>::push({0}& item) {{ __swift_bridge__$Vec_{1}$push(this->self, item); }}
template<>
{0} RustVec<{0}>::at(uintptr_t index) {{ return __swift_bridge__$Vec_{1}$get(this->self, index).val; }}
template<>
size_t RustVec<{0}>::size() {{ return (size_t)  __swift_bridge__$Vec_{1}$len(this->self); }}",
        $inner_type, $inner_function_name
        )
    };
}

/// Creates a class that maps onto the Rust Result<T, ErrorType> object.
/// The ownership depends on the source from which the object is created.
///
macro_rules! option_class {
    ($name:ident, $inner_type:ident) => {{
        let vec = vector_impl!($name, $name);
        format!(
            "
class {0} {{
    void* self = nullptr;
    bool is_owned = false;
public:
    {0}() = delete;
    {0}(void* self, bool is_owned = false) : self(self), is_owned(is_owned) {{ }}
    {0}({0}&& a) : self(a.self), is_owned(a.is_owned) {{ a.self = nullptr; a.is_owned = false; }};
    virtual ~{0}() {{ if(this->self && this->is_owned) {{ __swift_bridge__${0}$_free(this->self); }} }};
    {1} unwrap() {{ return {1}(__swift_bridge__${0}$unwrap(this->self), true); }}
    bool is_some() {{ return __swift_bridge__${0}$is_some(this->self); }}
    operator void*() const {{ return this->self; }}
}};
{2}\n",
            $name, $inner_type, vec
        )
    }};
}

/// Creates a class that maps onto the Rust Option<T> object.
/// The ownership depends on the source from which the object is created.
///
macro_rules! result_class {
    ($name:ident, $inner_type:ident) => {{
        let vec = vector_impl!($name, $name);
        format!(
            "
class {0} {{
    void* self = nullptr;
    bool is_owned = false;
public:
    {0}() = delete;
    {0}({0}&& a) : self(a.self), is_owned(a.is_owned) {{ a.self = nullptr; a.is_owned = false; }};
    {0}(void* self, bool is_owned = false) : self(self), is_owned(is_owned) {{ }}
    virtual ~{0}() {{ if(this->self && this->is_owned) {{ __swift_bridge__${0}$_free(this->self); }} }};
    {1} unwrap() {{ return {1}(__swift_bridge__${0}$unwrap(this->self), true); }}
    ErrorType unwrap_err() {{ return ErrorType(__swift_bridge__${0}$unwrap_err(this->self), true); }}
    bool is_ok() {{ return __swift_bridge__${0}$is_ok(this->self); }}
    operator void*() const {{ return this->self; }}
}};
{2}\n",
            $name, $inner_type, vec
        )
    }};
}

/// Creates a class that maps onto the custom structures with methods
/// that are available in the FFI.
/// The ownership depends on the source from which the object is created.
///
macro_rules! custom_class_declaration {
    ($name:ident, $functions_declaration:ident) => {{
        let vec = vector_impl!($name, $name);
        format!(
            "
class {0} {{
    void* self = nullptr;
    bool is_owned = false;
public:
    {0}() = delete;
    {0}(void* self, bool is_owned = false) : self(self), is_owned(is_owned) {{ }}
    {0}({0}&& a) : self(a.self), is_owned(a.is_owned) {{ a.self = nullptr; a.is_owned = false; }};
    virtual ~{0}() {{ if(this->self && this->is_owned) {{ __swift_bridge__${0}$_free(this->self); }} }};
    operator void*() const {{ return this->self; }}
{1}}};
{2}
\n",
            $name, $functions_declaration, vec
        )
    }};
}

/// The structure contains already translated elements of a function.
/// This can be usuful to generate declaration and definition of the
/// given function in two different places.
///
struct FunctionHelper {
    pub function_name: String,
    pub generated_args: String,
    pub generated_function_body: String,
    pub return_type_string: String,
    pub return_type: Option<WrapperType>,
}

impl FunctionHelper {
    /// Translates the intermediate form of a parsed function into
    /// the elements ready-to-use in the C++ code generation process.
    ///
    pub fn from_function(function: &Function, skip_first: bool) -> Self {
        let generated_args = function
            .arguments
            .iter()
            .skip(skip_first as usize)
            .map(|arg| match &arg.typ {
                WrapperType {
                    typ: RustWrapperType::Vector,
                    inner_type: Some(inner_type),
                    ..
                } => {
                    format!("RustVec<{}>& {}, ", inner_type.wrapper_name, arg.arg_name)
                }
                _ => {
                    format!("{}& {}, ", arg.typ.wrapper_name, arg.arg_name)
                }
            })
            .collect::<String>();
        let generated_function_body = function
            .arguments
            .iter()
            .skip(skip_first as usize)
            .map(|arg| format!("{}, ", arg.arg_name))
            .collect::<String>();
        let generated_function_body = if skip_first {
            format!("self, {}", generated_function_body)
        } else {
            generated_function_body
        };
        let return_type_string = function
            .return_type
            .as_ref()
            .map(|return_type| return_type.wrapper_name.to_string())
            .unwrap_or_else(|| "void".to_owned());
        let function_name = function.parsed_items.sig.ident.to_string();
        FunctionHelper {
            function_name,
            generated_args,
            generated_function_body,
            return_type_string,
            return_type: function.return_type.clone(),
        }
    }

    /// Generates a function declaration that can be used
    /// within a class declaration or for global functions.
    ///
    pub fn generate_declaration(&self) -> String {
        let FunctionHelper {
            function_name,
            generated_args,
            generated_function_body: _,
            return_type_string,
            return_type,
        } = self;
        match return_type {
            Some(WrapperType {
                typ: RustWrapperType::Vector,
                inner_type: Some(inner),
                ..
            }) => {
                let inner_name = &inner.wrapper_name;
                format!("    RustVec<{inner_name}> {function_name}({generated_args});\n")
            }
            _ => {
                format!("    {return_type_string} {function_name}({generated_args});\n")
            }
        }
    }

    ///
    /// TODO: add doc here
    ///
    pub fn generate_definition(&self, class_name: Option<&String>) -> String {
        let class_name_path = if let Some(ref class_name) = class_name {
            format!("{class_name}::")
        } else {
            "".to_owned()
        };
        let class_function_name = if let Some(class_name) = class_name {
            format!("{class_name}$")
        } else {
            "".to_owned()
        };
        let FunctionHelper {
            function_name,
            generated_args,
            generated_function_body,
            return_type_string,
            return_type,
        } = self;
        match return_type {
            Some(WrapperType {
                typ: RustWrapperType::Vector,
                inner_type: Some(inner),
                ..
            }) => {
                let inner_name = inner.wrapper_name.to_string();
                format!(
                    "RustVec<{inner_name}> {class_name_path}{function_name}({generated_args}) {{
    return
        RustVec<{inner_name}>(
            __swift_bridge__${class_function_name}{function_name}({generated_function_body}));\n}}\n"
                )
            }
            _ =>
                format!(
                        "{return_type_string} {class_name_path}{function_name}({generated_args}) {{
    return {return_type_string}(__swift_bridge__${class_function_name}{function_name}({generated_function_body}),
                                true);\n}}\n"),
        }
    }
}

///
/// TODO: add doc here
///
fn generate_functions_declaration(vec_of_functions_elems: &[FunctionHelper]) -> String {
    vec_of_functions_elems
        .iter()
        .map(|function_helper| function_helper.generate_declaration())
        .collect::<String>()
}

///
/// TODO: add doc here
///
fn generate_functions_definition(
    vec_of_functions_elems: &[FunctionHelper],
    class_name: Option<String>,
) -> String {
    vec_of_functions_elems
        .iter()
        .map(|function_helper| function_helper.generate_definition(class_name.as_ref()))
        .collect::<String>()
}

///
/// TODO: add doc here
///
pub fn generate_cpp_and_swig_file(
    extern_module_translator: &ExternModuleTranslator,
) -> GeneratedFilesContent {
    let classes_with_functions: HashSet<_> = extern_module_translator
        .structures_wrappers
        .keys()
        .cloned()
        .collect();
    let empty_types: String = extern_module_translator
        .rust_types_wrappers
        .difference(&classes_with_functions)
        .map(|wrapper| match wrapper {
            WrapperType {
                typ: RustWrapperType::Custom,
                ..
            } => {
                let class_name = wrapper.wrapper_name.to_string();
                let functions = "";
                custom_class_declaration!(class_name, functions)
            }
            _ => "".to_owned(),
        })
        .collect();

    let class_elements = extern_module_translator
        .structures_wrappers
        .iter()
        .map(|(wrapper_type, vec_of_functions)| {
            let function_elements = vec_of_functions
                .iter()
                .map(|f| FunctionHelper::from_function(f, true))
                .collect::<Vec<_>>();
            (wrapper_type, function_elements)
        })
        .collect::<Vec<_>>();

    let classes_declaration = class_elements
        .iter()
        .map(|(wrapper_type, vec_of_functions_elems)| {
            let functions_declaration = generate_functions_declaration(vec_of_functions_elems);
            let class_name = wrapper_type.wrapper_name.to_string();
            custom_class_declaration!(class_name, functions_declaration)
        })
        .collect::<String>();

    let classes_definition = class_elements
        .iter()
        .map(|(wrapper_type, vec_of_functions_elems)| {
            let class_name = wrapper_type.wrapper_name.to_string();
            generate_functions_definition(vec_of_functions_elems, Some(class_name))
        })
        .collect::<String>();

    let rust_types_wrappers: String = extern_module_translator
        .rust_types_wrappers
        .iter()
        .map(|wrapper| {
            let class_name = &wrapper.wrapper_name;
            match wrapper {
                WrapperType {
                    typ: RustWrapperType::Option,
                    inner_type: Some(inner),
                    ..
                } => {
                    let inner_type = inner.as_ref().wrapper_name.to_string();
                    option_class!(class_name, inner_type)
                }
                WrapperType {
                    typ: RustWrapperType::Result,
                    inner_type: Some(inner),
                    ..
                } => {
                    let inner_type = inner.as_ref().wrapper_name.to_string();
                    result_class!(class_name, inner_type)
                }
                _ => "".to_owned(),
            }
        })
        .collect();

    let global_functions_elems = extern_module_translator
        .global_functions
        .iter()
        .map(|f| FunctionHelper::from_function(f, false))
        .collect::<Vec<_>>();
    let global_functions_definition = generate_functions_definition(&global_functions_elems, None);

    let swig_templates: String = extern_module_translator
        .rust_types_wrappers
        .iter()
        .map(|key| match key.typ {
            RustWrapperType::Vector => format!(
                "%template(Vec{0}) RustVec<{0}>;\n",
                key.inner_type
                    .as_ref()
                    .expect("Vector has to have inner generic type")
                    .wrapper_name,
            ),
            _ => "".to_owned(),
        })
        .collect();

    let vector_rust_primitives: String = vec![
        vector_impl!("String", "RustString"),
        vector_primitive_impl!("u8", "u8"),
        vector_primitive_impl!("u16", "u16"),
        vector_primitive_impl!("u32", "u32"),
        vector_primitive_impl!("u64", "u64"),
        vector_primitive_impl!("i8", "i8"),
        vector_primitive_impl!("i16", "i16"),
        vector_primitive_impl!("i32", "i32"),
        vector_primitive_impl!("i64", "i64"),
        vector_primitive_impl!("bool", "bool"),
    ]
    .iter()
    .cloned()
    .collect();

    GeneratedFilesContent {
        // The order of definitions and declarations matters:
        cpp_header: format!(
            "{0}\n{1}\n{2}\n{3}\n{4}\n{5}\n{6}\n",
            PREDEFINED,
            vector_rust_primitives,
            empty_types,
            classes_declaration,
            rust_types_wrappers,
            global_functions_definition,
            classes_definition
        )
        .replace(", )", ")"), // remove trailing commas.
        swig_interface: swig_templates,
    }
}
