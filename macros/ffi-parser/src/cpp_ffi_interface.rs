/// The module consists of methods and structures for C++
/// and SWIG code generation. The generated code depends
/// on header files generated by `swift-bridge` crate.
///
use crate::{
    binding_types::{Function, RustWrapperType, WrapperType},
    extern_module_translator::ExternModuleTranslator,
};

/// Helper structure that consists of a generated C++ glue code
/// and SWIG interface file with templates.
///
pub struct GeneratedFilesContent {
    pub cpp_header: String,
    pub swig_interface: String,
}

impl GeneratedFilesContent {
    pub fn new(
        vector_defs_for_rust_primitives: &str,
        classes_declaration: &str,
        rust_types_wrappers: &str,
        global_functions_definition: &str,
        classes_definition: &str,
        swig_templates: &str,
    ) -> GeneratedFilesContent {
        GeneratedFilesContent {
            cpp_header: format!(
                "{PREDEFINED}
{vector_defs_for_rust_primitives}
{classes_declaration}
{rust_types_wrappers}
{global_functions_definition}
{classes_definition}"
            ),
            swig_interface: swig_templates.to_owned(),
        }
    }
}

/// Predefined C++ classes and primitive types typedefs useful
/// during the standard work on FFI basic structures. It
/// consists of a custom RustVector and String implementations
/// that keep track of some object ownership aspects. Items
/// returned by `RustVec::at(x)` method should be treated as
/// references, since the underlying objects are owned by
/// the vector.
///
const PREDEFINED: &str = "
#include <string>
#include <cstring>

typedef unsigned long u64;
typedef unsigned int u32;
typedef unsigned short u16;
typedef unsigned char u8;
typedef long i64;
typedef int i32;
typedef short i16;
typedef char i8;
typedef long unsigned int uintptr_t;

template <typename T>
class RustVec {
    void* self = nullptr;
public:
    RustVec() = delete;
    RustVec(RustVec&& a) : self(a.self) {
        a.self = nullptr;
    };
    RustVec(void* self) : self(self) {{}}
    virtual ~RustVec();
    operator void*() const { return this->self; }
    void push(T& item);
    T at(uintptr_t index);
    size_t size();
};

class String {
    void* self = nullptr;
    std::string str;
public:
    String() = delete;
    String(void* self, bool is_owned = true) : self(self) {{ }}
    String(const char* str) {
        this->str = std::string(str);
        RustStr s = RustStr {
            this->str.c_str(),
            this->str.size()
        };
        this->self = __swift_bridge__$RustString$new_with_str(s);
    }
    String(String&& a)
        : self(a.self) { 
              a.self = nullptr; 
    }
    std::string to_string() {
        RustStr s = __swift_bridge__$RustString$as_str(this->self);
        return std::string((const char*)s.start);
    }
    operator void*() const { return this->self; }
};
";

/// Creates an implementation of RustVec<T> for a given T that maps to the Rust Vec<T> object.
///
fn vector_impl(inner_type: &str, inner_function_name: &str) -> String {
    format!(
        "
template<>
RustVec<{inner_type}>::~RustVec()
{{
    if(this->self) {{
        __swift_bridge__$Vec_{inner_function_name}$drop(this->self);
    }}
}}
template<>
void RustVec<{inner_type}>::push({inner_type}& item) {{
    __swift_bridge__$Vec_{inner_function_name}$push(this->self, item);
}}
template<>
{inner_type} RustVec<{inner_type}>::at(uintptr_t index) {{ 
    return {inner_type}(__swift_bridge__$Vec_{inner_function_name}$get(this->self, index));
}}
template<>
size_t RustVec<{inner_type}>::size() {{
    return (size_t)  __swift_bridge__$Vec_{inner_function_name}$len(this->self);
}}"
    )
}

/// Creates an implementation of RustVec<T> for a given primitive type T that maps
/// to the Rust Vec<T> object.
///
fn vector_primitive_impl(inner_type: &str, inner_function_name: &str) -> String {
    format!(
        "
template<>
RustVec<{inner_type}>::~RustVec()
{{
    if(this->self) {{
        __swift_bridge__$Vec_{inner_function_name}$_free(this->self);
    }}
}}
template<>
void RustVec<{inner_type}>::push({inner_type}& item) {{
    __swift_bridge__$Vec_{inner_function_name}$push(this->self, item);
}}
template<>
{inner_type} RustVec<{inner_type}>::at(uintptr_t index) {{
    return __swift_bridge__$Vec_{inner_function_name}$get(this->self, index).val;
}}
template<>
size_t RustVec<{inner_type}>::size() {{
    return (size_t)  __swift_bridge__$Vec_{inner_function_name}$len(this->self);
}}"
    )
}

/// Creates a class that maps onto the Rust Option<T> object.
/// The ownership depends on the source from which the object is created.
///
fn option_class(name: &str, inner_type: &str) -> String {
    let vector_implementation = vector_impl(name, name);
    format!(
            "
class {name} {{
    void* self = nullptr;
    bool is_owned = false;
public:
    {name}() = delete;
    {name}(void* self, bool is_owned = false) : self(self), is_owned(is_owned) {{ }}
    {name}({name}&& a) : self(a.self), is_owned(a.is_owned) {{ a.self = nullptr; a.is_owned = false; }};
    virtual ~{name}() {{ if(this->self && this->is_owned) {{ __swift_bridge__${name}$_free(this->self); }} }};
    {inner_type} unwrap() {{ return {inner_type}(__swift_bridge__${name}$unwrap(this->self), true); }}
    bool is_some() {{ return __swift_bridge__${name}$is_some(this->self); }}
    operator void*() const {{ return this->self; }}
}};
{vector_implementation}\n")
}

/// Creates a class that maps onto the Rust Result<T, ErrorType> object.
/// The ownership depends on the source from which the object is created.
///
fn result_class(name: &str, inner_type: &str) -> String {
    let vector_implementation = vector_impl(name, name);
    format!(
            "
class {name} {{
    void* self = nullptr;
    bool is_owned = false;
public:
    {name}() = delete;
    {name}({name}&& a) : self(a.self), is_owned(a.is_owned) {{ a.self = nullptr; a.is_owned = false; }};
    {name}(void* self, bool is_owned = false) : self(self), is_owned(is_owned) {{ }}
    virtual ~{name}() {{ if(this->self && this->is_owned) {{ __swift_bridge__${name}$_free(this->self); }} }};
    {inner_type} unwrap() {{ return {inner_type}(__swift_bridge__${name}$unwrap(this->self), true); }}
    ErrorType unwrap_err() {{ return ErrorType(__swift_bridge__${name}$unwrap_err(this->self), true); }}
    bool is_ok() {{ return __swift_bridge__${name}$is_ok(this->self); }}
    operator void*() const {{ return this->self; }}
}};
{vector_implementation}\n")
}

/// Creates a class that maps onto the custom structures with methods
/// that are available in the FFI.
/// The ownership depends on the source from which the object is created.
///
fn custom_class_declaration(name: &str, functions_declaration: &str) -> String {
    let vec = vector_impl(name, name);
    format!(
            "
class {name} {{
    void* self = nullptr;
    bool is_owned = false;
public:
    {name}() = delete;
    {name}(void* self, bool is_owned = false) : self(self), is_owned(is_owned) {{ }}
    {name}({name}&& a) : self(a.self), is_owned(a.is_owned) {{ a.self = nullptr; a.is_owned = false; }};
    virtual ~{name}() {{ if(this->self && this->is_owned) {{ __swift_bridge__${name}$_free(this->self); }} }};
    operator void*() const {{ return this->self; }}
{functions_declaration}}};
{vec}
\n")
}

/// The structure contains already translated elements of a function.
/// This can be usuful to generate declaration and definition of the
/// given function in two different places.
///
struct FunctionHelper {
    pub function_name: String,
    pub generated_args: String,
    pub generated_function_body: String,
    pub return_type_string: String,
    pub return_type: Option<WrapperType>,
}

impl FunctionHelper {
    pub fn from_class_method(function: &Function) -> Self {
        FunctionHelper::from_function(function, true)
    }

    pub fn from_global_function(function: &Function) -> Self {
        FunctionHelper::from_function(function, false)
    }

    /// Translates the intermediate form of a parsed function into
    /// the elements ready-to-use in the C++ code generation process.
    ///
    fn from_function(function: &Function, skip_self_argument: bool) -> Self {
        let generated_args: String = function
            .arguments
            .iter()
            .skip(skip_self_argument as usize)
            .map(|arg| match &arg.typ {
                WrapperType {
                    typ: RustWrapperType::Vector,
                    inner_type: Some(inner_type),
                    ..
                } => format!("RustVec<{}>& {}", inner_type.wrapper_name, arg.arg_name),
                _ => format!("{}& {}", arg.typ.wrapper_name, arg.arg_name),
            })
            .collect::<Vec<String>>()
            .join(", ");
        let mut generated_function_body: Vec<String> = function
            .arguments
            .iter()
            .skip(skip_self_argument as usize)
            .map(|arg| arg.arg_name.to_string())
            .collect();
        if skip_self_argument {
            generated_function_body.insert(0, "this->self".to_owned());
        }
        let generated_function_body = generated_function_body.join(", ");
        let return_type_string = function
            .return_type
            .as_ref()
            .map(|return_type| return_type.wrapper_name.to_string())
            .unwrap_or_else(|| "void".to_owned());
        let function_name = function.parsed_items.sig.ident.to_string();
        FunctionHelper {
            function_name,
            generated_args,
            generated_function_body,
            return_type_string,
            return_type: function.return_type.clone(),
        }
    }

    /// Generates a function declaration that can be used
    /// within a class declaration or for global functions.
    ///
    pub fn generate_declaration(&self) -> String {
        let FunctionHelper {
            function_name,
            generated_args,
            generated_function_body: _,
            return_type_string,
            return_type,
        } = self;
        match return_type {
            Some(WrapperType {
                typ: RustWrapperType::Vector,
                inner_type: Some(inner),
                ..
            }) => {
                let inner_name = &inner.wrapper_name;
                format!("    RustVec<{inner_name}> {function_name}({generated_args});\n")
            }
            _ => format!("    {return_type_string} {function_name}({generated_args});\n"),
        }
    }

    /// Generates a method definition that can be placed
    /// outside the class declaration. It can also generate
    /// a global function if `class_name` string is not provided
    /// (the function is not associated to any type).
    ///
    pub fn generate_definition(&self, class_name: Option<&String>) -> String {
        let class_name_path = if let Some(ref class_name) = class_name {
            format!("{class_name}::")
        } else {
            "".to_owned()
        };
        let class_function_name = if let Some(class_name) = class_name {
            format!("{class_name}$")
        } else {
            "".to_owned()
        };
        let FunctionHelper {
            function_name,
            generated_args,
            generated_function_body,
            return_type_string,
            return_type,
        } = self;
        match return_type {
            Some(WrapperType {
                typ: RustWrapperType::Vector,
                inner_type: Some(inner),
                ..
            }) => {
                let inner_name = inner.wrapper_name.to_string();
                format!(
                    "RustVec<{inner_name}> {class_name_path}{function_name}({generated_args}) {{
    return
        RustVec<{inner_name}>(
            __swift_bridge__${class_function_name}{function_name}({generated_function_body}));\n}}\n"
                )
            }
            _ =>
                format!(
                        "{return_type_string} {class_name_path}{function_name}({generated_args}) {{
    return {return_type_string}(__swift_bridge__${class_function_name}{function_name}({generated_function_body}),
                                true);\n}}\n"),
        }
    }
}

fn generate_functions_declaration(
    functions_helpers: impl Iterator<Item = FunctionHelper>,
) -> String {
    functions_helpers
        .map(|function_helper| function_helper.generate_declaration())
        .collect()
}

fn generate_functions_definition(
    functions_helpers: impl Iterator<Item = FunctionHelper>,
    class_name: Option<String>,
) -> String {
    functions_helpers
        .map(|function_helper| function_helper.generate_definition(class_name.as_ref()))
        .collect()
}

/// Results of this function can be written in the `*.hpp` and `*.i` files.
/// The generated C++ header file + header generated by `swift-bridge` can
/// be used in C++ application. Those files + `*.i` file can be included
/// to the SWIG interface file and used to generate glue code for Java, C# etc.
///
pub fn generate_cpp_and_swig_file(
    extern_module_translator: &ExternModuleTranslator,
) -> GeneratedFilesContent {
    let classes_declaration = extern_module_translator
        .structures_wrappers
        .iter()
        .map(|(wrapper_type, vec_of_functions)| {
            let functions_declaration = generate_functions_declaration(
                vec_of_functions
                    .iter()
                    .map(FunctionHelper::from_class_method),
            );
            let class_name = wrapper_type.wrapper_name.to_string();
            custom_class_declaration(&class_name, &functions_declaration)
        })
        .collect::<String>();

    let classes_definition = extern_module_translator
        .structures_wrappers
        .iter()
        .map(|(wrapper_type, vec_of_functions)| {
            let class_name = wrapper_type.wrapper_name.to_string();
            generate_functions_definition(
                vec_of_functions
                    .iter()
                    .map(FunctionHelper::from_class_method),
                Some(class_name),
            )
        })
        .collect::<String>();

    let rust_types_wrappers: String = extern_module_translator
        .rust_types_wrappers
        .iter()
        .map(|wrapper| {
            let class_name = &wrapper.wrapper_name;
            match wrapper {
                WrapperType {
                    typ: RustWrapperType::Option,
                    inner_type: Some(inner),
                    ..
                } => {
                    let inner_type = inner.as_ref().wrapper_name.to_string();
                    option_class(&class_name.to_string(), &inner_type)
                }
                WrapperType {
                    typ: RustWrapperType::Result,
                    inner_type: Some(inner),
                    ..
                } => {
                    let inner_type = inner.as_ref().wrapper_name.to_string();
                    result_class(&class_name.to_string(), &inner_type)
                }
                _ => "".to_owned(),
            }
        })
        .collect();

    let global_functions_definition = generate_functions_definition(
        extern_module_translator
            .global_functions
            .iter()
            .map(FunctionHelper::from_global_function),
        None,
    );

    let swig_templates: String = extern_module_translator
        .rust_types_wrappers
        .iter()
        .map(|key| match key.typ {
            RustWrapperType::Vector => format!(
                "%template(Vec{0}) RustVec<{0}>;\n",
                key.inner_type
                    .as_ref()
                    .expect("Vector has to have inner generic type")
                    .wrapper_name,
            ),
            _ => "".to_owned(),
        })
        .collect();

    let vector_defs_for_rust_primitives: String = vec![
        vector_impl("String", "RustString"),
        vector_primitive_impl("u8", "u8"),
        vector_primitive_impl("u16", "u16"),
        vector_primitive_impl("u32", "u32"),
        vector_primitive_impl("u64", "u64"),
        vector_primitive_impl("i8", "i8"),
        vector_primitive_impl("i16", "i16"),
        vector_primitive_impl("i32", "i32"),
        vector_primitive_impl("i64", "i64"),
        vector_primitive_impl("bool", "bool"),
    ]
    .join("");

    GeneratedFilesContent::new(
        &vector_defs_for_rust_primitives,
        &classes_declaration,
        &rust_types_wrappers,
        &global_functions_definition,
        &classes_definition,
        &swig_templates,
    )
}
